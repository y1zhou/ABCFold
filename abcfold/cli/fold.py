"""Run ABCFold with the given configuration."""

from pathlib import Path
from typing import Annotated

import typer

from abcfold.boltz.run_boltz_abcfold import run_boltz
from abcfold.schema import load_abcfold_config

app = typer.Typer()


@app.command(name="af3")
def fold_af3(
    conf_file: Annotated[
        Path, typer.Argument(help="Path to the ABCFold configuration file.")
    ],
    out_dir: Annotated[
        Path,
        typer.Option(
            ...,
            "--out-dir",
            "-o",
            help="Output directory for prepared files.",
        ),
    ],
):
    """Build structure models with AF3."""
    raise NotImplementedError("AF3 is very low priority. Please use `abcfold` instead.")


@app.command(name="chai")
def fold_chai(
    conf_file: Annotated[
        Path, typer.Argument(help="Path to the ABCFold configuration file.")
    ],
    out_dir: Annotated[
        Path,
        typer.Option(
            ...,
            "--out-dir",
            "-o",
            help="Output directory for prepared files.",
        ),
    ],
    chai_yaml_file: Annotated[
        Path,
        typer.Option(
            ...,
            "--chai-yaml-file",
            "-i",
            help="Path to the Chai configuration file generated by `abcfold2 prepare chai`.",
        ),
    ],
    use_esm_embeddings: Annotated[
        bool,
        typer.Option(
            help="Whether to use ESM embeddings in Chai.",
        ),
    ] = True,
    template_hits_path: Annotated[
        Path | None,
        typer.Option(
            help="Path to template hits file (in m8 format).",
        ),
    ] = None,
    template_cif_dir: Annotated[
        Path | None,
        typer.Option(
            help="Directory containing template mmCIF files.",
        ),
    ] = None,
    recycle_msa_subsample: Annotated[
        int,
        typer.Option(
            help="Number of sequences to subsample from the MSA for recycling. Default is 0 (no subsampling).",
        ),
    ] = 0,
    low_memory: Annotated[
        bool,
        typer.Option(
            help="Whether to use low memory mode in Chai.",
        ),
    ] = True,
):
    """Build structure models with Chai."""
    import os

    from abcfold.chai1.run_chai1_abcfold import run_chai

    conf_path = conf_file.expanduser().resolve()
    conf = load_abcfold_config(conf_path)

    chai_conf_path = chai_yaml_file.expanduser().resolve()
    if not chai_conf_path.exists():
        raise FileNotFoundError(f"Chai config file not found: {chai_conf_path}")

    out_path = out_dir.expanduser().resolve()
    out_path.mkdir(parents=True, exist_ok=True)
    if template_cif_dir is not None:
        os.environ["CHAI_TEMPLATE_CIF_FOLDER"] = str(template_cif_dir)
    run_chai(
        abcfold_conf=conf,
        output_dir=out_path,
        chai_yaml_file=chai_conf_path,
        template_hits_path=template_hits_path,
        template_cif_dir=template_cif_dir,
        use_esm_embeddings=use_esm_embeddings,
        recycle_msa_subsample=recycle_msa_subsample,
        low_memory=low_memory,
    )


@app.command(name="boltz")
def fold_boltz(
    conf_file: Annotated[
        Path, typer.Argument(help="Path to the ABCFold configuration file.")
    ],
    boltz_yaml_file: Annotated[
        Path,
        typer.Option(
            ..., "--boltz-yaml-file", "-i", help="Path to the Boltz configuration file."
        ),
    ],
    out_dir: Annotated[
        Path,
        typer.Option(
            ...,
            "--out-dir",
            "-o",
            help="Output directory for Boltz.",
        ),
    ],
):
    """Build structure models with Boltz."""
    conf_path = conf_file.expanduser().resolve()
    conf = load_abcfold_config(conf_path)

    boltz_conf_path = boltz_yaml_file.expanduser().resolve()
    if not boltz_conf_path.exists():
        raise FileNotFoundError(f"Boltz config file not found: {boltz_conf_path}")

    out_path = out_dir.expanduser().resolve()
    out_path.mkdir(parents=True, exist_ok=True)
    run_boltz(conf, boltz_conf_path, out_path, boltz_conf_path.stem)


if __name__ == "__main__":
    app()
